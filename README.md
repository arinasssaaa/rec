# Ширкина Арина УИБО-10-24
# Работа с массивами
# Вариант 17
## Задача: __Напишите функцию для подсчета количества листьев в бинарном дереве.__
## Алгоритм Python:
1. Если узел не существует (root is None), возвращаем 0.
2. Если узел является листом (нет левого и правого потомков), возвращаем 1.
3. Рекурсивно суммируем количество листьев в левом и правом поддеревьях.
## Сложность: 
O(n), где n — количество узлов. 
Обусловеленно тем что: алгоритм посещает каждый узел ровно один раз, что приводит к линейной зависимости от числа узлов.
## Алгоритм Java:
проверка на null, определение листа, рекурсивный подсчет в поддеревьях.
## Сложность:
O(n). 
Обусловленно тем что: каждый узел обрабатывается один раз, что гарантирует линейное время выполнения.
## Алгоритм C++:
1. Проверка на nullptr.
2. Возврат 1 для листьев.
3. Рекурсивный вызов для левого и правого поддеревьев.
## Сложность:
O(n). 
Обусловлено тем что: все узлы посещаются ровно один раз, что обеспечивает линейную сложность.
## Объяснение временной сложности

Во всех реализациях используется рекурсивный обход в глубину (DFS).

· O(n): алгоритм проходит каждый узел дерева ровно один раз, где n — общее количество узлов. 
· Почему? Для каждого узла выполняется проверка на наличие потомков, и рекурсия продолжается для не-null потомков. Это исключает повторные обработки узлов.

Пример для дерева из 7 узлов:

```
      1
     / \
    2   3
   / \   \
  4   5   6
     /
    7
```

Количество листьев: 3 (узлы 4, 7, 6). Алгоритм посетит все 7 узлов, выполнив 7 операций.
## Контрольный вопрос 4
## Вопрос: Что такое мемоизация и как она помогает оптимизировать рекурсивные алгоритмы?
Мемоизация — это техника оптимизации, которая сохраняет результаты выполнения функций для определенных входных данных и возвращает сохраненный результат при повторных вызовах с теми же аргументами. Это особенно полезно для рекурсивных алгоритмов, где одни и те же вычисления могут выполняться многократно.

Как это работает:

1. Кэширование результатов: При первом вызове функции с определенными аргументами результат сохраняется в структуре данных (например, хэш-таблице).
2. Проверка кэша: Перед вычислением проверяется, есть ли уже результат для данных аргументов.
3. Повторное использование: Если результат есть в кэше, он возвращается без повторного вычисления.
   
Преимущества мемоизации:

1. Сокращение времени выполнения: Избегает повторных вычислений.
2. Уменьшение сложности: Например, для чисел Фибоначчи сложность уменьшается с O(2^n) до O(n).
3. Универсальность: Применима к любым детерминированным функциям.

Ограничения:

· Потребление памяти: Требуется дополнительная память для хранения результатов.
· Применимость: Работает только для чистых функций (одинаковые входы → одинаковые выходы).

