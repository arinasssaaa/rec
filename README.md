# Ширкина Арина УИБО-10-24
# Работа с массивами
# Вариант 17
## Задача: __Напишите функцию для подсчета количества листьев в бинарном дереве.__
## Алгоритм Python:
1. Если узел не существует (root is None), возвращаем 0.
2. Если узел является листом (нет левого и правого потомков), возвращаем 1.
3. Рекурсивно суммируем количество листьев в левом и правом поддеревьях.
## Сложность: 
O(n), где n — количество узлов. 
Обусловеленно тем что: алгоритм посещает каждый узел ровно один раз, что приводит к линейной зависимости от числа узлов.
## Алгоритм Java:
проверка на null, определение листа, рекурсивный подсчет в поддеревьях.
## Сложность:
O(n). 
Обусловленно тем что: каждый узел обрабатывается один раз, что гарантирует линейное время выполнения.
## Алгоритм C++:
1. Проверка на nullptr.
2. Возврат 1 для листьев.
3. Рекурсивный вызов для левого и правого поддеревьев.
## Сложность:
O(n). 
Обусловлено тем что: все узлы посещаются ровно один раз, что обеспечивает линейную сложность.
## Объяснение временной сложности

Во всех реализациях используется рекурсивный обход в глубину (DFS).

· O(n): алгоритм проходит каждый узел дерева ровно один раз, где n — общее количество узлов. 
· Почему? Для каждого узла выполняется проверка на наличие потомков, и рекурсия продолжается для не-null потомков. Это исключает повторные обработки узлов.

Пример для дерева из 7 узлов:

```
      1
     / \
    2   3
   / \   \
  4   5   6
     /
    7
```

Количество листьев: 3 (узлы 4, 7, 6). Алгоритм посетит все 7 узлов, выполнив 7 операций.
